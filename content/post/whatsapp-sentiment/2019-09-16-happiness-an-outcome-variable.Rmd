---
title: 'Happiness : An Outcome Variable'
author: ''
date: '2019-09-16'
slug: happiness-an-outcome-variable
categories: []
#tags:
#  - personal
#  - nlp
#  - tidytext
subtitle: ''
summary: ''
authors: []
#lastmod: '2019-09-16T22:10:23-05:00'
featured: no
image:
  caption: ''
  focal_point: ''
  preview_only: no
projects: []
---
<span style="font-size:0.8em;">
<p align="justify">

Iâ€™ve been feeling with growing certainty that barring extreme circumstances and mental or physical illness, whether or not you feel happy on a daily basis is mostly a function of habits. I've noticed, anecdotally, that I tend to be happier on days I get adequate sunshine, exercise, don't use my phone too much, actually *watch* tv as opposed to letting Grey's Anatomy play while I scroll aimlessly through Twitter, etc. Conversely, I'm more likely to wake up early, go outdoors, be productive, read and engage with other human beings on days I'm feeling happier. 
</br></br>
Lately, I've become curious about the [Quantified Self](https://quantifiedself.com/) movement; it advocates the pursuit of self-knowledge through numbers. Thanks to the fact that tech is ubiquitously (and creepily) tracking our every action, there's plenty of data that's already passively being collected about each of us. For data about myself, I pulled my daily steps off my iPhone using [this app](https://apps.apple.com/us/app/qs-access/id920297614), my Netflix history, financial transactions (to track daily activities - everything costs $ except the lake, parks and libraries) and transcripts of WhatsApp conversations. To account for factors beyond my control, I pulled temperature, location and hours of daylight for each day of observation.
</br></br>
If I want to understand the predictors of my happy days, I need some measure of my daily happiness. Since I haven't actively been tracking my moods with a mood journal or an app like [Happify](https://happify.com/) or [Track Your Happiness](https://www.trackyourhappiness.org/), I have to wade back into this data and come up with some metric to use as a proxy. 
</br></br>
I live and work on a continent that's very far away from my family and several friends - as a result, some of my closest and most meaningful relationships are conducted online. Since I often talk about my day over text message with people who weren't part of my day, I wondered if the words I use to talk about my day could be mined to compute a *happiness score*, for want of a better term. 
</p></span>



```{r, warning=FALSE, message=FALSE, echo=FALSE}
knitr::opts_chunk$set(echo = FALSE)

library(tidyverse)
library(lubridate)
library(ggplot2)
detach('package:dplyr')
library(dplyr)
library(tidytext)
library(sentimentr)
library(viridis)
library(magrittr)
library(wesanderson)

process_text <- function(filename){
  df <- read.csv(filename, header = TRUE, stringsAsFactors = FALSE) %>% 
  select(datetime, sender, text) %>% 
  mutate(datetime = dmy_hms(datetime),
         date = date(datetime),
         day = lubridate::wday(date, label = TRUE, abbr = FALSE),
         dialogue_split = get_sentences(text)) %$%
  sentiment_by(dialogue_split, list(sender,date)) %>% 
  mutate(norm_sentiment = ave_sentiment/word_count)
  return(df)
}

chats <-list.files('data')
d <- process_text(paste('data/',chats[1], sep = '')) %>% 
  mutate(sender = ifelse(sender == 'Didige','Friend 1','Me'))
n <- process_text(paste('data/',chats[2], sep = '')) %>% 
  mutate(sender = ifelse(sender == 'Nikhil','Friend 2','Me'))
p <- process_text(paste('data/',chats[3], sep = '')) %>% 
  mutate(sender = ifelse(sender == 'Pranathi','Friend 3','Me'))
r <- process_text(paste('data/',chats[4], sep = '')) %>% 
  mutate(sender = ifelse(sender == 'Riddhima','Friend 4','Me'))

friends <- bind_rows(d,n,p,r) %>% 
  mutate(binary_sender = case_when(sender == 'Me' ~ 'Sent',
                                   TRUE ~ 'Received'))
```

```{r}
t <- read_csv(paste('data/',chats[1], sep = '')) %>% 
  select(datetime, sender, text) %>% 
  mutate(datetime = dmy_hms(datetime),
         date = date(datetime),
         day = lubridate::wday(date, label = TRUE, abbr = FALSE)) %>% 
     group_by(date,sender) %>% 
     mutate(all_text = paste0(text, collapse = " ")) %>% 
  select(date, sender, all_text) %>% 
  unique()
```
```{r}
t <- t %>% 
  mutate(all_text = str_replace_all(all_text, 'image omitted', ' ')) %>% 
  select(all_text, everything()) %>% 
  mutate(all_text = textclean::replace_emoji(all_text)) %>% 
  mutate(all_text = str_replace_all(all_text, "\\<[a-z][a-z]\\>", ' '),
         all_text = str_replace_all(all_text, "\\<[a-z][0-9]\\>", ' '),
         all_text = str_replace_all(all_text, "\\<[0-9][a-z]\\>", ' '),
         all_text = str_replace_all(all_text, "\\<[0-9][0-9]\\>", ' '))
```



```{r}
friends %>% 
  mutate(day = lubridate::wday(date, label = TRUE, abbr = FALSE)) %>% 
  drop_na() %>% 
  group_by(day, binary_sender) %>% 
  summarize(avg = mean(ave_sentiment)) %>% 
  ggplot() + 
  geom_col(aes(x = day, y = avg, group = binary_sender, fill = binary_sender), position = 'dodge') +
  theme_minimal() +
  scale_fill_manual(values = wes_palette(name = "GrandBudapest2")) +
  xlab(NULL) +
  ylab('Average Sentiment') +
  theme(legend.title = element_blank()) +
  ggtitle('Day of Week')

```

```{r, message=FALSE}
friends %>% 
  #mutate(day = lubridate::month(date, label = TRUE, abbr = FALSE)) %>% 
  drop_na() %>% 
  group_by(date, binary_sender) %>% 
  summarize(avg = mean(ave_sentiment)) %>% 
  ggplot() + 
  geom_smooth(aes(x = date, y = avg, group = binary_sender, colour = binary_sender), se = FALSE, span = 0.4) +
  theme_minimal() +
  scale_colour_manual(values = wes_palette(name = "GrandBudapest2")) +
  xlab(NULL) +
  ylab('Average Sentiment') +
  theme(legend.title = element_blank()) +
  ggtitle('Time of Year') 
  
```



```{r, message=FALSE, warning=FALSE, fig.width=8,fig.height=5}
plot_line <- function(df,title){
  g <- df %>% 
  ggplot() +
  geom_smooth(aes(x = date, y = ave_sentiment, group = sender, colour = sender), span = 0.3, se = FALSE) +
  theme_minimal( )+
  scale_colour_manual(values = wes_palette(name = "GrandBudapest2"))  +
  xlab(NULL) +
  ylab('Average Sentiment') +
  theme(legend.title = element_blank()) +
  ggtitle(title) 
  return(g)
}
gridExtra::grid.arrange(plot_line(d, 'Friend 1'),
             plot_line(n, 'Friend 2'),
             plot_line(p, 'Friend 3'),
             plot_line(r, 'Friend 4'),
             ncol = 2)

```



